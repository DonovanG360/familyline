#!/usr/bin/env python

#
#   Tribalia CLI communication with the server
#
#   Copyright (C) 2018 Arthur M
#
#   The server will use port 12000 to communicate with the 
#   client, and listen to port 12100 to communicate with any 
#   'requester'.
#   See the server admin protocol file for some information
#
# P.S: This is Python 3. If you use Python 2, you are a failure to your family.
#

import socket, time


class Server:
    """
    The server class. Abstract server information 
    """

    def __init__(self, ipaddr):
        """ 
        Initializes the class
        :param ipaddr: The IP address, as a string
        """
        self.ipaddr = ipaddr
        self.port = 12100
        self.socket = -1
        self.intid = -1
        self.lastChatDownload = 0

    def disconnect(self):
        """
        Disconnect from the server
        """
        self.socket.shutdown(socket.SHUT_RDWR)
        self.socket.close()
        
    def connect(self):
        """ 
        Connect to the server
        :return: True if the connection was successful, or 
        throws an exception if not
        """
        self.socket = socket.socket(socket.AF_INET, 
                socket.SOCK_STREAM)
        self.socket.connect((self.ipaddr, self.port))

        rmsg = self.socket.recv(128).decode()
        rmsgarr = rmsg.split(' ')

        self.intid = int(rmsgarr[2])
        if rmsgarr[3] != "()":
            raise Exception('Unsupported flags')

        self.socket.send('[TRIBALIA INTERFACE OK ]\n'.encode('utf-8'))
        
        return True

    def getPlayers(self):
        """
        Get information about the players currently connected
        :return: An array of dictionaries with player information
         The field 'name' will contain the player name, 'ip' the IP, 
         'id' the ID and 'xp' the experience
        """
        self.socket.sendall("[TRIBALIA REQUEST PLAYERS ]\n".encode("utf-8"))
        sresponse = self.socket.recv(512).decode()
        stokens = sresponse.split(' ')

        # Split in tokens, so we'll have something like 
        # ['[TRIBALIA', 'RESPONSE', 'PLAYERS', '<<player_count>>', '<<p1_id>>'...]
        # Player count is index 3
        # First player info is index 4-7 (ID, name, exp and IP address)
        # Second player info is index 8-11, etc

        # TODO: Join quote-delimited names.

        count = int(stokens[3])
        ret = []
        idx = 0
        while idx < count:
            ret.append({'id': int(stokens[4+(idx*5)]),
                    'name': stokens[4+(idx*5)+1],
                    'xp': int(stokens[4+(idx*5)+2]),
                    'status': stokens[4+(idx*5)+3],
                    'ip': stokens[4+(idx*5)+4]
            })
            idx += 1
       
        return ret

    def sendChat(self, content, playerid = -1):
        """
        Send a chat message to some player, or -1 to send to everyone
        :param content: The message data
        :param playerid: The player ID, or -1 for 'all'
        """

        # len(bytes) because we want the number of bytes in the message,
        # not the number of chars!
        msg = "[TRIBALIA SEND-CHAT all {} {} ]\n".format(
                len(bytes(content, 'utf-8')), content)
        self.socket.send(msg.encode('utf-8'))

    def sendCommand(self, cmd):
        """
        Send a command to the server. The command is anything prefixed 
        by a slash (like /maps). 
        :return: the text generated by the server
        """
        pass

    def downloadChat(self):
        """
        Download chat messages
        :return: An array of dictionaries with chat info.
        'username' is the sender name, 'timestamp' is the msg timestamp and
        'message' is the actual message
        """
        self.socket.send("[TRIBALIA REQUEST CHAT {} ]\n".format(
            self.lastChatDownload).encode('utf-8'))
        self.lastChatDownload = int(time.time())
        time.sleep(0.1) 
        resp = self.socket.recv(32768).decode()
        ret = []
        print(resp)

        # Receive the great number of messages
        for msg in resp.split(']'):
            if len(msg) < 7:
                continue

            print(msg)
            msgslots = msg.split(' ')
            if len(msgslots) < 7:
                continue
                
            timestamp = int(msgslots[2])
            senderid = int(msgslots[3])
            sendername = msgslots[4]
            sendertype = msgslots[5]
            msgsize = msgslots[6]
            msgdata = ' '.join(msgslots[7:]).strip()
            ret.append({
                'timestamp': timestamp,
                'sendername': sendername,
                'msg': msgdata
            })

        return ret


def write_messages(msgs):
    ypos = 2
    for msg in msgs:
        stdscr.addstr(ypos, 1, "[{}] {}".format(
            msg['sendername'], msg['msg']))
        ypos += 1

    stdscr.noutrefresh()
    curses.doupdate()


def create_player_window(wPlayer = None):
    # Create the player window
    # That window will have the player information
    # It will have the screen height and 1/4 of its width
    wPlayerWidth = curses.COLS//4

    if wPlayer is None:
        wPlayer = curses.newwin(curses.LINES, wPlayerWidth, 0, (3*curses.COLS)//4)

    wPlayer.refresh()
    wPlayer.addstr(1, max(1, (wPlayerWidth//2)-4), "Players", 
            curses.color_pair(1) | curses.A_BOLD)
    for i in range(1, wPlayerWidth-1):
        wPlayer.addch(2, i, curses.ACS_HLINE)
    
    wPlayer.border()
    wPlayer.noutrefresh()
    return wPlayer

def create_command_input_window(wCommand = None):
    # Create the command input window
    # It will only have one usable line, but this can be grown
    #

    if wCommand is None:
        wCommand = curses.newwin(3, (3*curses.COLS//4), curses.LINES-3, 0)

    wCommand.refresh()
    wCommand.addstr(1, 1, '> ')
    wCommand.border()
    wCommand.noutrefresh()
    return wCommand

def player_window_refresh_players(wPlayer, arrPlayers):
    # Refresh the player names written in the window
    linenum = 3
    for pl in arrPlayers:
        pair = 0
        if pl['status'] == 'connecting':
            pair = curses.color_pair(3)
        else:
            pair = curses.color_pair(2)

        wPlayer.addstr(linenum, 1, " - %s" % pl['name'],
                pair | curses.A_BOLD)
        linenum += 1

    wPlayer.noutrefresh()

def do_quit(cmd):
    curses.endwin()
    print("\033[36mBye :)\033[0m", cmd)

import curses
import sys #.exit

print("""
 Tribalia Server command line client
 Copyright (C) 2018 Arthur M.
 Licensed under MIT license
""")

server = None

try:
    server = Server("127.0.0.1")
    server.connect()
except Exception as e:
    print("Error: " + repr(e))
    sys.exit(1)

stdscr = curses.initscr()
curses.start_color()

# Creates the default color pairs
curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK) # The 'title'
curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK) # The 'connected client'
curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK) # The 'connecting client'
curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK) # The 'error'

stdscr.clear()

stdscr.addstr(2, 1, "Connecting...")
stdscr.noutrefresh()
curses.doupdate()


wPlayer = create_player_window()
wCommand = create_command_input_window()

rplayers = server.getPlayers()
chats = server.downloadChat()

curses.doupdate()
doquit = False

# List of commands and the respective functions
commands = {
        'quit': do_quit
}


# Command receive loop
# Reads the command and do something nice. Also refresh the console
stdscr.clear()
while not doquit:
    cmd = ""
    try:
        rplayers = server.getPlayers()
        chats.extend(server.downloadChat())

        stdscr.clear()
        write_messages(chats[-25:])
        wPlayer = create_player_window(wPlayer)
        player_window_refresh_players(wPlayer, rplayers)

        wCommand.clear()
        wCommand = create_command_input_window(wCommand)
        
        curses.doupdate()

        cmd = wCommand.getstr(1, 3).decode()
        cmd = cmd.strip()

        if cmd[0] != '/':
            server.sendChat(cmd, -1)
            continue

        cmd = cmd.lower()
        cmd = cmd[1:]
        if cmd == "":
            continue
        elif cmd == "quit" or cmd == "exit":
            doquit = True
        else:
            commands[cmd](cmd)
    except KeyError:
        stdscr.clear()
    
        # Refresh all windows
        stdscr.addstr(curses.LINES - 5, 1, "Command %s not found" % cmd,
                curses.color_pair(4) | curses.A_BOLD)
        stdscr.refresh()
        curses.doupdate()

    except KeyboardInterrupt:
        doquit = True

server.disconnect()
do_quit('')
