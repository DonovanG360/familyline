// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INPUTSERIALIZE_FAMILYLINE_H_
#define FLATBUFFERS_GENERATED_INPUTSERIALIZE_FAMILYLINE_H_

#include "flatbuffers/flatbuffers.h"

namespace familyline {

struct PlayerInfo;
struct PlayerInfoBuilder;

struct CommandInputArgs;
struct CommandInputArgsBuilder;

struct CommandInput;
struct CommandInputBuilder;

struct SelectActionObjects;
struct SelectActionObjectsBuilder;

struct SelectAction;
struct SelectActionBuilder;

struct ObjectMove;
struct ObjectMoveBuilder;

struct CameraMove;
struct CameraMoveBuilder;

struct CameraRotate;
struct CameraRotateBuilder;

struct CreateEntity;
struct CreateEntityBuilder;

struct InputElement;
struct InputElementBuilder;

struct InputFile;
struct InputFileBuilder;

enum InputType {
  InputType_NONE = 0,
  InputType_cmd = 1,
  InputType_sel = 2,
  InputType_obj_move = 3,
  InputType_cam_move = 4,
  InputType_cam_rotate = 5,
  InputType_create = 6,
  InputType_MIN = InputType_NONE,
  InputType_MAX = InputType_create
};

inline const InputType (&EnumValuesInputType())[7] {
  static const InputType values[] = {
    InputType_NONE,
    InputType_cmd,
    InputType_sel,
    InputType_obj_move,
    InputType_cam_move,
    InputType_cam_rotate,
    InputType_create
  };
  return values;
}

inline const char * const *EnumNamesInputType() {
  static const char * const names[8] = {
    "NONE",
    "cmd",
    "sel",
    "obj_move",
    "cam_move",
    "cam_rotate",
    "create",
    nullptr
  };
  return names;
}

inline const char *EnumNameInputType(InputType e) {
  if (flatbuffers::IsOutRange(e, InputType_NONE, InputType_create)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInputType()[index];
}

template<typename T> struct InputTypeTraits {
  static const InputType enum_value = InputType_NONE;
};

template<> struct InputTypeTraits<familyline::CommandInput> {
  static const InputType enum_value = InputType_cmd;
};

template<> struct InputTypeTraits<familyline::SelectAction> {
  static const InputType enum_value = InputType_sel;
};

template<> struct InputTypeTraits<familyline::ObjectMove> {
  static const InputType enum_value = InputType_obj_move;
};

template<> struct InputTypeTraits<familyline::CameraMove> {
  static const InputType enum_value = InputType_cam_move;
};

template<> struct InputTypeTraits<familyline::CameraRotate> {
  static const InputType enum_value = InputType_cam_rotate;
};

template<> struct InputTypeTraits<familyline::CreateEntity> {
  static const InputType enum_value = InputType_create;
};

bool VerifyInputType(flatbuffers::Verifier &verifier, const void *obj, InputType type);
bool VerifyInputTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct PlayerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_COLOR = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *color() const {
    return GetPointer<const flatbuffers::String *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyString(color()) &&
           verifier.EndTable();
  }
};

struct PlayerInfoBuilder {
  typedef PlayerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(PlayerInfo::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlayerInfo::VT_NAME, name);
  }
  void add_color(flatbuffers::Offset<flatbuffers::String> color) {
    fbb_.AddOffset(PlayerInfo::VT_COLOR, color);
  }
  explicit PlayerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerInfo>(end);
    fbb_.Required(o, PlayerInfo::VT_NAME);
    fbb_.Required(o, PlayerInfo::VT_COLOR);
    return o;
  }
};

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> color = 0) {
  PlayerInfoBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_color(color);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    const char *color = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto color__ = color ? _fbb.CreateString(color) : 0;
  return familyline::CreatePlayerInfo(
      _fbb,
      id,
      name__,
      color__);
}

struct CommandInputArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandInputArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGS = 4
  };
  const flatbuffers::Vector<uint64_t> *args() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.EndTable();
  }
};

struct CommandInputArgsBuilder {
  typedef CommandInputArgs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_args(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> args) {
    fbb_.AddOffset(CommandInputArgs::VT_ARGS, args);
  }
  explicit CommandInputArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CommandInputArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandInputArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandInputArgs> CreateCommandInputArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> args = 0) {
  CommandInputArgsBuilder builder_(_fbb);
  builder_.add_args(args);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommandInputArgs> CreateCommandInputArgsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<uint64_t>(*args) : 0;
  return familyline::CreateCommandInputArgs(
      _fbb,
      args__);
}

struct CommandInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_ARGS = 6
  };
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  const familyline::CommandInputArgs *args() const {
    return GetPointer<const familyline::CommandInputArgs *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyTable(args()) &&
           verifier.EndTable();
  }
};

struct CommandInputBuilder {
  typedef CommandInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(CommandInput::VT_COMMAND, command);
  }
  void add_args(flatbuffers::Offset<familyline::CommandInputArgs> args) {
    fbb_.AddOffset(CommandInput::VT_ARGS, args);
  }
  explicit CommandInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CommandInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandInput>(end);
    fbb_.Required(o, CommandInput::VT_COMMAND);
    return o;
  }
};

inline flatbuffers::Offset<CommandInput> CreateCommandInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<familyline::CommandInputArgs> args = 0) {
  CommandInputBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_command(command);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommandInput> CreateCommandInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr,
    flatbuffers::Offset<familyline::CommandInputArgs> args = 0) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return familyline::CreateCommandInput(
      _fbb,
      command__,
      args);
}

struct SelectActionObjects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectActionObjectsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint64_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct SelectActionObjectsBuilder {
  typedef SelectActionObjects Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> values) {
    fbb_.AddOffset(SelectActionObjects::VT_VALUES, values);
  }
  explicit SelectActionObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SelectActionObjects> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectActionObjects>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectActionObjects> CreateSelectActionObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> values = 0) {
  SelectActionObjectsBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<SelectActionObjects> CreateSelectActionObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<uint64_t>(*values) : 0;
  return familyline::CreateSelectActionObjects(
      _fbb,
      values__);
}

struct SelectAction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4
  };
  const familyline::SelectActionObjects *objects() const {
    return GetPointer<const familyline::SelectActionObjects *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyTable(objects()) &&
           verifier.EndTable();
  }
};

struct SelectActionBuilder {
  typedef SelectAction Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<familyline::SelectActionObjects> objects) {
    fbb_.AddOffset(SelectAction::VT_OBJECTS, objects);
  }
  explicit SelectActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SelectAction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectAction>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectAction> CreateSelectAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<familyline::SelectActionObjects> objects = 0) {
  SelectActionBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

struct ObjectMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectMoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_POS = 4,
    VT_Y_POS = 6
  };
  uint32_t x_pos() const {
    return GetField<uint32_t>(VT_X_POS, 0);
  }
  uint32_t y_pos() const {
    return GetField<uint32_t>(VT_Y_POS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_X_POS) &&
           VerifyField<uint32_t>(verifier, VT_Y_POS) &&
           verifier.EndTable();
  }
};

struct ObjectMoveBuilder {
  typedef ObjectMove Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_pos(uint32_t x_pos) {
    fbb_.AddElement<uint32_t>(ObjectMove::VT_X_POS, x_pos, 0);
  }
  void add_y_pos(uint32_t y_pos) {
    fbb_.AddElement<uint32_t>(ObjectMove::VT_Y_POS, y_pos, 0);
  }
  explicit ObjectMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectMove> CreateObjectMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t x_pos = 0,
    uint32_t y_pos = 0) {
  ObjectMoveBuilder builder_(_fbb);
  builder_.add_y_pos(y_pos);
  builder_.add_x_pos(x_pos);
  return builder_.Finish();
}

struct CameraMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraMoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_DELTA = 4,
    VT_Y_DELTA = 6,
    VT_ZOOM_DELTA = 8
  };
  double x_delta() const {
    return GetField<double>(VT_X_DELTA, 0.0);
  }
  double y_delta() const {
    return GetField<double>(VT_Y_DELTA, 0.0);
  }
  double zoom_delta() const {
    return GetField<double>(VT_ZOOM_DELTA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X_DELTA) &&
           VerifyField<double>(verifier, VT_Y_DELTA) &&
           VerifyField<double>(verifier, VT_ZOOM_DELTA) &&
           verifier.EndTable();
  }
};

struct CameraMoveBuilder {
  typedef CameraMove Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_delta(double x_delta) {
    fbb_.AddElement<double>(CameraMove::VT_X_DELTA, x_delta, 0.0);
  }
  void add_y_delta(double y_delta) {
    fbb_.AddElement<double>(CameraMove::VT_Y_DELTA, y_delta, 0.0);
  }
  void add_zoom_delta(double zoom_delta) {
    fbb_.AddElement<double>(CameraMove::VT_ZOOM_DELTA, zoom_delta, 0.0);
  }
  explicit CameraMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraMove> CreateCameraMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x_delta = 0.0,
    double y_delta = 0.0,
    double zoom_delta = 0.0) {
  CameraMoveBuilder builder_(_fbb);
  builder_.add_zoom_delta(zoom_delta);
  builder_.add_y_delta(y_delta);
  builder_.add_x_delta(x_delta);
  return builder_.Finish();
}

struct CameraRotate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraRotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIANS = 4
  };
  double radians() const {
    return GetField<double>(VT_RADIANS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RADIANS) &&
           verifier.EndTable();
  }
};

struct CameraRotateBuilder {
  typedef CameraRotate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radians(double radians) {
    fbb_.AddElement<double>(CameraRotate::VT_RADIANS, radians, 0.0);
  }
  explicit CameraRotateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraRotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraRotate>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraRotate> CreateCameraRotate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double radians = 0.0) {
  CameraRotateBuilder builder_(_fbb);
  builder_.add_radians(radians);
  return builder_.Finish();
}

struct CreateEntity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateEntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_X_POS = 6,
    VT_Y_POS = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  uint32_t x_pos() const {
    return GetField<uint32_t>(VT_X_POS, 0);
  }
  uint32_t y_pos() const {
    return GetField<uint32_t>(VT_Y_POS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint32_t>(verifier, VT_X_POS) &&
           VerifyField<uint32_t>(verifier, VT_Y_POS) &&
           verifier.EndTable();
  }
};

struct CreateEntityBuilder {
  typedef CreateEntity Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(CreateEntity::VT_TYPE, type);
  }
  void add_x_pos(uint32_t x_pos) {
    fbb_.AddElement<uint32_t>(CreateEntity::VT_X_POS, x_pos, 0);
  }
  void add_y_pos(uint32_t y_pos) {
    fbb_.AddElement<uint32_t>(CreateEntity::VT_Y_POS, y_pos, 0);
  }
  explicit CreateEntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreateEntity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateEntity>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateEntity> CreateCreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint32_t x_pos = 0,
    uint32_t y_pos = 0) {
  CreateEntityBuilder builder_(_fbb);
  builder_.add_y_pos(y_pos);
  builder_.add_x_pos(x_pos);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateEntity> CreateCreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    uint32_t x_pos = 0,
    uint32_t y_pos = 0) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return familyline::CreateCreateEntity(
      _fbb,
      type__,
      x_pos,
      y_pos);
}

struct InputElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICK = 4,
    VT_PLAYERCODE = 6,
    VT_TIMESTAMP = 8,
    VT_TYPE_TYPE = 10,
    VT_TYPE = 12
  };
  uint64_t tick() const {
    return GetField<uint64_t>(VT_TICK, 0);
  }
  uint64_t playercode() const {
    return GetField<uint64_t>(VT_PLAYERCODE, 0);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  familyline::InputType type_type() const {
    return static_cast<familyline::InputType>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const familyline::CommandInput *type_as_cmd() const {
    return type_type() == familyline::InputType_cmd ? static_cast<const familyline::CommandInput *>(type()) : nullptr;
  }
  const familyline::SelectAction *type_as_sel() const {
    return type_type() == familyline::InputType_sel ? static_cast<const familyline::SelectAction *>(type()) : nullptr;
  }
  const familyline::ObjectMove *type_as_obj_move() const {
    return type_type() == familyline::InputType_obj_move ? static_cast<const familyline::ObjectMove *>(type()) : nullptr;
  }
  const familyline::CameraMove *type_as_cam_move() const {
    return type_type() == familyline::InputType_cam_move ? static_cast<const familyline::CameraMove *>(type()) : nullptr;
  }
  const familyline::CameraRotate *type_as_cam_rotate() const {
    return type_type() == familyline::InputType_cam_rotate ? static_cast<const familyline::CameraRotate *>(type()) : nullptr;
  }
  const familyline::CreateEntity *type_as_create() const {
    return type_type() == familyline::InputType_create ? static_cast<const familyline::CreateEntity *>(type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TICK) &&
           VerifyField<uint64_t>(verifier, VT_PLAYERCODE) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyInputType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const familyline::CommandInput *InputElement::type_as<familyline::CommandInput>() const {
  return type_as_cmd();
}

template<> inline const familyline::SelectAction *InputElement::type_as<familyline::SelectAction>() const {
  return type_as_sel();
}

template<> inline const familyline::ObjectMove *InputElement::type_as<familyline::ObjectMove>() const {
  return type_as_obj_move();
}

template<> inline const familyline::CameraMove *InputElement::type_as<familyline::CameraMove>() const {
  return type_as_cam_move();
}

template<> inline const familyline::CameraRotate *InputElement::type_as<familyline::CameraRotate>() const {
  return type_as_cam_rotate();
}

template<> inline const familyline::CreateEntity *InputElement::type_as<familyline::CreateEntity>() const {
  return type_as_create();
}

struct InputElementBuilder {
  typedef InputElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tick(uint64_t tick) {
    fbb_.AddElement<uint64_t>(InputElement::VT_TICK, tick, 0);
  }
  void add_playercode(uint64_t playercode) {
    fbb_.AddElement<uint64_t>(InputElement::VT_PLAYERCODE, playercode, 0);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(InputElement::VT_TIMESTAMP, timestamp, 0);
  }
  void add_type_type(familyline::InputType type_type) {
    fbb_.AddElement<uint8_t>(InputElement::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(InputElement::VT_TYPE, type);
  }
  explicit InputElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputElement> CreateInputElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t tick = 0,
    uint64_t playercode = 0,
    uint64_t timestamp = 0,
    familyline::InputType type_type = familyline::InputType_NONE,
    flatbuffers::Offset<void> type = 0) {
  InputElementBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_playercode(playercode);
  builder_.add_tick(tick);
  builder_.add_type(type);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

struct InputFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_INFO = 4,
    VT_INPUT_ELEMENT = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<familyline::PlayerInfo>> *player_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<familyline::PlayerInfo>> *>(VT_PLAYER_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<familyline::InputElement>> *input_element() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<familyline::InputElement>> *>(VT_INPUT_ELEMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER_INFO) &&
           verifier.VerifyVector(player_info()) &&
           verifier.VerifyVectorOfTables(player_info()) &&
           VerifyOffset(verifier, VT_INPUT_ELEMENT) &&
           verifier.VerifyVector(input_element()) &&
           verifier.VerifyVectorOfTables(input_element()) &&
           verifier.EndTable();
  }
};

struct InputFileBuilder {
  typedef InputFile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<familyline::PlayerInfo>>> player_info) {
    fbb_.AddOffset(InputFile::VT_PLAYER_INFO, player_info);
  }
  void add_input_element(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<familyline::InputElement>>> input_element) {
    fbb_.AddOffset(InputFile::VT_INPUT_ELEMENT, input_element);
  }
  explicit InputFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InputFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputFile> CreateInputFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<familyline::PlayerInfo>>> player_info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<familyline::InputElement>>> input_element = 0) {
  InputFileBuilder builder_(_fbb);
  builder_.add_input_element(input_element);
  builder_.add_player_info(player_info);
  return builder_.Finish();
}

inline flatbuffers::Offset<InputFile> CreateInputFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<familyline::PlayerInfo>> *player_info = nullptr,
    const std::vector<flatbuffers::Offset<familyline::InputElement>> *input_element = nullptr) {
  auto player_info__ = player_info ? _fbb.CreateVector<flatbuffers::Offset<familyline::PlayerInfo>>(*player_info) : 0;
  auto input_element__ = input_element ? _fbb.CreateVector<flatbuffers::Offset<familyline::InputElement>>(*input_element) : 0;
  return familyline::CreateInputFile(
      _fbb,
      player_info__,
      input_element__);
}

inline bool VerifyInputType(flatbuffers::Verifier &verifier, const void *obj, InputType type) {
  switch (type) {
    case InputType_NONE: {
      return true;
    }
    case InputType_cmd: {
      auto ptr = reinterpret_cast<const familyline::CommandInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputType_sel: {
      auto ptr = reinterpret_cast<const familyline::SelectAction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputType_obj_move: {
      auto ptr = reinterpret_cast<const familyline::ObjectMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputType_cam_move: {
      auto ptr = reinterpret_cast<const familyline::CameraMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputType_cam_rotate: {
      auto ptr = reinterpret_cast<const familyline::CameraRotate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case InputType_create: {
      auto ptr = reinterpret_cast<const familyline::CreateEntity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyInputTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyInputType(
        verifier,  values->Get(i), types->GetEnum<InputType>(i))) {
      return false;
    }
  }
  return true;
}

inline const familyline::InputFile *GetInputFile(const void *buf) {
  return flatbuffers::GetRoot<familyline::InputFile>(buf);
}

inline const familyline::InputFile *GetSizePrefixedInputFile(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<familyline::InputFile>(buf);
}

inline const char *InputFileIdentifier() {
  return "FREC";
}

inline bool InputFileBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, InputFileIdentifier());
}

inline bool VerifyInputFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<familyline::InputFile>(InputFileIdentifier());
}

inline bool VerifySizePrefixedInputFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<familyline::InputFile>(InputFileIdentifier());
}

inline const char *InputFileExtension() {
  return "frec";
}

inline void FinishInputFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<familyline::InputFile> root) {
  fbb.Finish(root, InputFileIdentifier());
}

inline void FinishSizePrefixedInputFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<familyline::InputFile> root) {
  fbb.FinishSizePrefixed(root, InputFileIdentifier());
}

}  // namespace familyline

#endif  // FLATBUFFERS_GENERATED_INPUTSERIALIZE_FAMILYLINE_H_
